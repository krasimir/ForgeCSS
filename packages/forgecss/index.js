import { writeFile } from "fs/promises";
import getAllFiles from "./lib/getAllFiles.js";
import { extractStyles, invalidateInvetory } from "./lib/inventory.js";
import { invalidateUsageCache, findUsages } from "./lib/processor.js";
import { generateOutputCSS } from "./lib/generator.js";

const DEFAULT_OPTIONS = {
  inventoryFiles: ["css", "less", "scss"],
  usageFiles: ["html", "jsx", "tsx"],
  usageAttributes: ["class", "className"],
  mapping: {
    queries: {}
  }
};

export default function ForgeCSS(options) {
  const config = { ...DEFAULT_OPTIONS };

  config.mapping = {
    queries: Object.assign({}, DEFAULT_OPTIONS.mapping.queries, options?.mapping?.queries ?? {})
  };

  async function result(output) {
    try {
      const css = await generateOutputCSS(config);
      if (output) {
        await writeFile(output, `/* ForgeCSS autogenerated file */\n${css}`, "utf-8");
      }
      return css;
    } catch (err) {
      console.error(`forgecss: error generating output CSS: ${err}`);
    }
    return null;
  }

  return {
    async parseDirectory({ dir, output = null }) {
      if (!dir) {
        throw new Error('forgecss: parseDirectory requires "dir" as an argument.');
      }
      try {
        // filling the inventory
        let files = await getAllFiles(dir, config.inventoryFiles);
        for (let file of files) {
          await extractStyles(file);
        }
      } catch (err) {
        console.error(`forgecss: error extracting styles.`, err);
      }
      // finding the usages
      try {
        let files = await getAllFiles(dir, config.usageFiles);
        for (let file of files) {
          await findUsages(file);
        }
      } catch (err) {
        console.error(`forgecss: error extracting usages`, err);
      }
      // generating the output CSS
      return result(output);
    },
    async parseFile({ file, output = null }) {
      if (!file) {
        throw new Error('forgecss: parseFile requires "file" as an argument.');
      }
      const ext = file.split(".").pop().toLowerCase();
      // filling the inventory
      try {
        if (config.inventoryFiles.includes(ext)) {
          await extractStyles(file);
        }
      } catch (err) {
        console.error(`forgecss: error extracting styles.`, err);
      }
      // finding the usages
      try {
        if (config.usageFiles.includes(ext)) {
          invalidateUsageCache(file);
          await findUsages(file);
        }
      } catch (err) {
        console.error(`forgecss: error extracting usages.`, err);
      }
      // generating the output CSS
      return result(output);
    },
    async parse({ css, html, jsx, output = null }) {
      if (!css) {
        throw new Error('forgecss: parse requires "css".');
      }
      if (!html && !jsx) {
        throw new Error('forgecss: parse requires "html" or "jsx".');
      }
      invalidateInvetory();
      invalidateUsageCache();
      // filling the inventory
      try {
        await extractStyles("styles.css", css);
      } catch (err) {
        console.error(`forgecss: error extracting styles.`, err);
      }
      // finding the usages
      try {
        if (html) {
          await findUsages("usage.html", html);
        } else if (jsx) {
          await findUsages("usage.jsx", jsx);
        }
      } catch (err) {
        console.error(`forgecss: error extracting usages.`, err);
      }
      return result(output);
    }
  };
}
